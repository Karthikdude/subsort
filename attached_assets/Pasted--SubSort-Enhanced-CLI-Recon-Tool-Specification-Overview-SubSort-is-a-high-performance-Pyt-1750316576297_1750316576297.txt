# SubSort - Enhanced CLI Recon Tool Specification

## 🎯 Overview
SubSort is a high-performance, Python-based CLI reconnaissance tool that automates comprehensive subdomain analysis with modular functionality, advanced anti-bot detection, and optimized concurrency.

## 🚀 Performance & Speed Optimizations

### Core Libraries & Dependencies
```
# HTTP & Networking
aiohttp >= 3.8.0          # Async HTTP client with connection pooling
httpx >= 0.24.0           # Alternative async HTTP with HTTP/2 support
asyncio                   # Core async functionality
aiofiles >= 22.1.0        # Async file I/O operations

# DNS & Network Analysis
aiodns >= 3.0.0           # Async DNS resolution
dnspython >= 2.3.0        # DNS toolkit
python-nmap >= 0.7.1      # Nmap integration
scapy >= 2.5.0            # Network packet manipulation

# Data Processing & Analysis
pandas >= 2.0.0           # Data manipulation and analysis
numpy >= 1.24.0           # Numerical computations
beautifulsoup4 >= 4.12.0  # HTML parsing
lxml >= 4.9.0             # Fast XML/HTML parser
PyJWT >= 2.6.0            # JWT token handling
cryptography >= 40.0.0   # SSL/TLS certificate analysis

# Fingerprinting & Detection
python-wappalyzer >= 0.3.1    # Technology detection
Wappalyzer >= 0.2.2           # Alternative tech detection
whatweb-python >= 1.0.0      # Web technology identification
sslyze >= 5.1.0              # SSL/TLS analyzer
censys >= 2.2.0              # Certificate transparency logs

# Performance & Caching
redis >= 4.5.0           # Caching layer for results
diskcache >= 5.6.0       # Disk-based caching
joblib >= 1.2.0          # Parallel processing utilities
multiprocessing-logging   # Thread-safe logging

# CLI & Output
click >= 8.1.0           # CLI framework
rich >= 13.0.0           # Rich terminal output
colorama >= 0.4.6        # Cross-platform colored output
tabulate >= 0.9.0        # Pretty table formatting
tqdm >= 4.65.0           # Progress bars

# Security & Anti-Detection
fake-useragent >= 1.4.0  # Random user agents
requests-html >= 0.10.0  # JavaScript rendering capability
selenium >= 4.8.0        # Browser automation (for JS-heavy sites)
undetected-chromedriver  # Anti-detection browser driver
```

### Speed Optimization Algorithms & Techniques

#### 1. Adaptive Connection Pooling
- Dynamic pool sizing based on target responsiveness
- Connection reuse with keep-alive optimization
- Circuit breaker pattern for failing hosts
- Exponential backoff with jitter for rate limiting

#### 2. Intelligent Batching System
```
Batch Size Algorithm:
- Start with batch_size = min(50, total_subdomains / threads)
- Adjust based on success rate:
  - >90% success: increase by 25%
  - 70-90% success: maintain
  - <70% success: decrease by 50%
- Maximum batch size: 200
- Minimum batch size: 5
```

#### 3. Smart Timeout Management
- Base timeout: 5s (configurable)
- Adaptive timeout based on historical response times
- Progressive timeout: first request 3s, retry 7s, final 15s
- Geographic-based timeout adjustment

#### 4. Memory-Efficient Processing
- Streaming JSON processing for large datasets
- Generator-based subdomain processing
- Memory-mapped file reading for huge input files
- Garbage collection optimization between batches

## 🛡️ Advanced Anti-Bot Detection System

### Default Anti-Detection Features
```python
# Automatic Rotation Systems
USER_AGENTS: Rotate 500+ real browser user agents
HEADERS: Randomize Accept, Accept-Language, Accept-Encoding
TLS_FINGERPRINTS: Rotate TLS/SSL handshake fingerprints
PROXY_ROTATION: Optional proxy chain support

# Behavioral Mimicking
HUMAN_DELAYS: Random delays between 0.5-3.0 seconds
REQUEST_PATTERNS: Vary request timing and order
COOKIE_HANDLING: Automatic cookie jar management
REFERER_SPOOFING: Set realistic referer headers

# Advanced Evasion
HEADLESS_BROWSER: Use undetected-chromedriver when needed
JS_EXECUTION: Handle JavaScript-rendered content
CAPTCHA_DETECTION: Skip hosts with CAPTCHA challenges
WAF_DETECTION: Identify and adapt to WAF responses
```

### Anti-Detection Configuration
```
--stealth-mode         # Maximum evasion (slower but harder to detect)
--proxy-file          # Load proxy list for rotation
--user-agent-file     # Custom user agent list
--delay-range         # Custom delay range (e.g., 1-5)
--max-retries         # Retry attempts per subdomain (default: 3)
--rotate-interval     # Rotate fingerprints every N requests
```

## 📊 Enhanced Module Specifications

### Core Modules with Algorithms

#### --techstack (Technology Stack Detection)
```
Libraries: python-wappalyzer, whatweb-python
Algorithm: Multi-layer fingerprinting
- Header analysis (Server, X-Powered-By, etc.)
- HTML pattern matching (regex-based)
- JavaScript library detection
- CSS framework identification
- Meta tag analysis
Output: tech_stack_[timestamp].txt
```

#### --vhost (Virtual Host Detection)
```
Libraries: aiohttp, aiodns
Algorithm: Host header manipulation
- Test different Host headers
- Compare response variations
- Detect IP-based vs name-based vhosts
- SSL certificate SAN analysis
Output: vhost_detection_[timestamp].txt
```

#### --faviconhash (Favicon Hash Generation)
```
Libraries: hashlib, mmh3 (MurmurHash3)
Algorithm: Multiple hash algorithms
- MD5, SHA1, SHA256 hashes
- MurmurHash3 (Shodan-compatible)
- Perceptual hashing for similar favicons
- Base64 encoding of favicon data
Output: favicon_hashes_[timestamp].txt
```

#### --jsvuln (JavaScript Vulnerability Detection)
```
Libraries: retire.js data, custom CVE database
Algorithm: Version extraction and CVE matching
- Extract library versions from JS files
- Match against known vulnerable versions
- Severity scoring (CVSS integration)
- Dependency chain analysis
Output: js_vulnerabilities_[timestamp].txt
```

#### --cname (CNAME Takeover Detection)
```
Libraries: aiodns, custom service fingerprints
Algorithm: Service availability checking
- Resolve CNAME chains
- Check service availability (404, NXDOMAIN)
- Test common takeover services
- Validate subdomain claim possibility
Output: cname_takeover_[timestamp].txt
```

#### --ssl (SSL Certificate Analysis)
```
Libraries: sslyze, cryptography
Algorithm: Certificate chain analysis
- Extract certificate details
- Check expiration dates
- Analyze certificate transparency logs
- Detect weak cipher suites
- SAN (Subject Alternative Names) enumeration
Output: ssl_analysis_[timestamp].txt
```

#### --port (Port Scanning)
```
Libraries: python-nmap, asyncio-based scanner
Algorithm: Adaptive scanning strategy
- Common ports first (80, 443, 22, 21, etc.)
- Service detection on open ports
- Banner grabbing with timeout
- OS fingerprinting when possible
Output: port_scan_[timestamp].txt
```

### Advanced Modules

#### --cloudassets (Cloud Asset Discovery)
```
Libraries: boto3, azure-storage-blob, google-cloud-storage
Algorithm: URL pattern recognition
- Extract potential S3/Azure/GCS URLs from content
- Test public access permissions
- List bucket contents when possible
- Check for sensitive file patterns
Output: cloud_assets_[timestamp].txt
```

#### --dirscan (Directory Discovery)
```
Libraries: aiohttp with custom wordlists
Algorithm: Intelligent directory bruteforcing
- Adaptive wordlist selection based on tech stack
- Response code analysis (200, 301, 302, 403)
- Content-length based duplicate detection
- Recursive scanning for discovered directories
Wordlists: SecLists, common.txt, technology-specific lists
Output: directories_[timestamp].txt
```

#### --vulnscan (Vulnerability Scanning)
```
Libraries: nuclei-python, custom templates
Algorithm: Template-based vulnerability detection
- Load Nuclei community templates
- Custom signature matching
- Severity-based result sorting
- False positive reduction
Output: vulnerabilities_[timestamp].txt
```

## 🔧 Enhanced CLI Arguments & Configuration

### Performance Arguments
```bash
--threads INT              # Concurrent threads (default: 50, max: 200)
--batch-size INT          # Subdomains per batch (default: auto-calculated)
--timeout INT             # Request timeout in seconds (default: 5)
--max-redirects INT       # Maximum redirects to follow (default: 3)
--connection-pool INT     # HTTP connection pool size (default: 100)
--dns-servers TEXT        # Custom DNS servers (comma-separated)
--rate-limit INT          # Requests per second limit (default: unlimited)
```

### Output & Logging Arguments
```bash
-v, --verbose             # Enable verbose logging
--log-level CHOICE        # Log level: DEBUG, INFO, WARNING, ERROR
--log-file PATH           # Custom log file path
--output-format CHOICE    # Output format: txt, json, csv, xml
--no-color               # Disable colored output
--progress-bar           # Show progress bar
--save-raw               # Save raw HTTP responses
```

### Advanced Detection Arguments
```bash
--stealth-mode           # Enable all anti-detection features
--user-agent TEXT        # Custom user agent string
--proxy-url TEXT         # Single proxy URL
--proxy-file PATH        # File containing proxy list
--delay-range TEXT       # Delay range between requests (e.g., "1-3")
--retries INT            # Retry attempts per failed request
--ignore-ssl             # Ignore SSL certificate errors
--follow-redirects       # Follow HTTP redirects
```

## 📝 Verbose Logging System (-v/--verbose)

### Log Levels & Categories
```
DEBUG Level:
- HTTP request/response headers
- DNS resolution details
- SSL handshake information
- Timing information for each operation
- Memory usage statistics
- Thread allocation details

INFO Level:
- Subdomain processing start/completion
- Module execution status
- Success/failure counts
- Performance metrics
- Rate limiting information

WARNING Level:
- Timeout occurrences
- SSL certificate issues
- Unusual response codes
- Rate limiting triggers
- Anti-bot detection alerts

ERROR Level:
- Connection failures
- DNS resolution failures
- Module execution errors
- File I/O errors
- Critical system errors
```

### Detailed Log Format
```
[2024-06-19 14:32:15.123] [THREAD-05] [DEBUG] [TECHSTACK] 
  → Analyzing: example.com
  → Request: GET https://example.com/ 
  → Headers: {'User-Agent': 'Mozilla/5.0...', 'Accept': 'text/html...'}
  → Response: 200 OK (1.23s)
  → Technologies: [Nginx/1.18.0, PHP/8.1.2, jQuery/3.6.0]
  → Memory: 45.2MB, CPU: 12.3%

[2024-06-19 14:32:16.456] [MAIN] [INFO] [PROGRESS]
  → Processed: 150/1000 subdomains (15.0%)
  → Success Rate: 89.3%
  → Average Response Time: 2.1s
  → Estimated Time Remaining: 12m 34s
```

## 🏗️ File Structure & Output Organization

### Output Directory Structure
```
output/
├── logs/
│   ├── subsort_2024-06-19_14-32-15.log
│   └── errors_2024-06-19_14-32-15.log
├── raw_responses/              # --save-raw flag
│   ├── example_com_response.html
│   └── subdomain2_com_response.json
├── tech_stack_2024-06-19.txt
├── ssl_analysis_2024-06-19.txt
├── port_scan_2024-06-19.txt
├── vulnerabilities_2024-06-19.txt
└── summary_report_2024-06-19.json
```

### Example Enhanced Usage
```bash
# Comprehensive recon with verbose logging
subsort -i subdomains.txt \
  --techstack --ssl --port --vulnscan --cloudassets \
  --threads 100 --timeout 10 --stealth-mode \
  -v --log-level DEBUG --progress-bar \
  --output-format json --save-raw

# Fast basic recon
subsort -i subs.txt --status --server --title \
  --threads 200 --rate-limit 50 --silent

# Stealth comprehensive scan
subsort -i targets.txt --all-modules \
  --stealth-mode --proxy-file proxies.txt \
  --delay-range "2-5" --retries 5 -v
```

## 🔒 Error Handling & Resilience

### Graceful Failure Management
- Per-module error isolation
- Automatic retry with exponential backoff
- Circuit breaker for consistently failing hosts
- Partial result saving on interruption
- Resume capability from checkpoint files
- Memory leak prevention with periodic cleanup

### Health Monitoring
- Real-time success rate tracking
- Performance degradation detection
- Resource usage monitoring
- Automatic thread count adjustment
- Connection pool health checks

This enhanced specification provides a robust foundation for building a professional-grade reconnaissance tool with enterprise-level performance and reliability.